// BloombergHandler.cpp: implementation of the CBloombergHandler class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Bloomberg.h"
#include "BloombergHandler.h"
#include "SendCancelReject.h"
#include "FixSession.h"
//#include "BloombergReplace.h"
//#include "BloombergReject.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBloombergHandler::CBloombergHandler()
{
	CMessageApp *pApp = (CMessageApp *)AfxGetApp();

	m_pTags	= new CBloombergMemTagSet();
	m_pTags->InitMap();
	// get the default clearing account
	GetPrivateProfileString("Clearing Information",	"Default Clearing Code",	"", m_DefaultAccount.GetBuffer(128), 128,	pApp->DatFile()); 
	m_DefaultAccount.ReleaseBuffer();
}

CBloombergHandler::~CBloombergHandler()
{
	delete m_pTags;
}


/////////////////////////////////////////////////////////////////////////////////////////////
// from client to fix

void CBloombergHandler::ProcessMessage(COrder& Order)
{
	long		SequenceNumber	= 0;
	CString		Error			= "";
	CString		Account;
	CBloombergApp *pApp			= (CBloombergApp *)AfxGetApp();	
	CString sSourceID = Order.SourceId();
	//Order.SetSourceId("845544");
	Order.SetSourceId(pApp->SenderSubId());

	if ( (pApp->Host()).LoggedOn() != TRUE)
	{
		// generate reject message
		CReject	Reject("Unable To Send", Order);
		
		// map tags
		Order.SetSourceId(sSourceID);
		m_pTags->CreateNewMap(Order.StaffordTag(), Order.OrderTag(), -1, Order.SourceId());
	
		// update Status
		pApp->Status().SetStatus(Reject);
		pApp->ProcessDebug("ORDER REJECT", Order.Debug());
		return;
	}

	try
	{
		// lookup and set traders clearing account code
		if (Order.ClearingId() == "")
		{
			Order.SetClearingId(m_DefaultAccount);	
		}

		Order.SetOrderTag(((CFixSession&) pApp->Exchange()).GetNextOutgoingSeqNum());

		if ((SequenceNumber = pApp->Exchange().ProcessEntry(Order)) > 0)
		{
			// map tags
			m_pTags->CreateNewMap(Order.StaffordTag(), Order.OrderTag(), SequenceNumber, Order.SourceId());		
			m_pTags->SetOriginalPrice(Order.dPrice());
			m_pTags->SetShares(Order.Shares());
			m_pTags->SetClient(sSourceID);
			m_pTags->SetOriginalShares(Order.Shares());

			// update status
			pApp->Status().SetStatus(Order);
			pApp->ProcessDebug("ORDER SENT", Order.Debug());
		}
		else
		{
			// generate reject message
			CReject	Reject("Unable To Send", Order);		
			// map tags
			Order.SetSourceId(sSourceID);
			m_pTags->CreateNewMap(Order.StaffordTag(), Order.OrderTag(), -1, Order.SourceId());
		
			// update Status
			pApp->Status().SetStatus(Reject);
			pApp->ProcessDebug("ORDER REJECT", Order.Debug());
		}
	}

	catch (CDBException *e)
	{
		Error.Format("DB EXCEPTION: Error Processing Outgoing Message (%s): %s", e->m_strError, Order.Debug());
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler Exception", Error);
		e->Delete();
	}
	catch (const char *Message)
	{
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler Exception", Message);
	}	
}

void CBloombergHandler::ProcessMessage(CCancel& Cancel)
{
	CString		Error;
	CMessageApp *pApp = (CMessageApp *)AfxGetApp();

	try
	{
		if (m_pTags->GetTags(MAP_STAFFORD_TAG_QUERY, Cancel.StaffordTag()))
		{
			// set the exchange's tag an the fix order tag
			Cancel.SetExchangeTag(m_pTags->ExchangeTag());
			Cancel.SetOrderTag(m_pTags->OrderTag());
			Cancel.SetCancelTag(((CFixSession&) pApp->Exchange()).GetNextOutgoingSeqNum());
			
			if (pApp->Exchange().ProcessCancel(Cancel))
			{
				// set the cancel tag 
				m_pTags->SetCancelTag(Cancel.CancelTag());

				// update Status
				Cancel.SetSourceId(m_pTags->Client());
				pApp->Status().SetStatus(Cancel);
				pApp->ProcessDebug("CANCEL SENT", Cancel.Debug());
			}
			else
			{
				// generate reject
				Cancel.SetSourceId(m_pTags->Client());
				CSendCancelReject	Reject(Cancel);		
				// set the cancel tag which is generated by the fix session
				m_pTags->SetCancelTag(Cancel.CancelTag());

				// update Status
				pApp->Status().SetStatus(Reject);
				pApp->ProcessDebug("SEND REJECT", Cancel.Debug());
			}
		}
	}

	catch (CDBException *e)
	{
		Error.Format("EXCEPTION: Error Processing Outgoing Message (%s): %s", e->m_strError, Cancel.Debug());
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Error);
		e->Delete();
	}
	catch (const char *Message)
	{
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Message);
	}
}

void CBloombergHandler::ProcessMessage(CExecution& Execution)
{
	CString		Error;
	CMessageApp *pApp = (CMessageApp *)AfxGetApp();		

	try
	{	
		if (Execution.Status() != COrder::PendingCancel)
		{
			if(Execution.Status() == COrder::Replaced) 
			{
				if (m_pTags->GetTags(MAP_ORDER_TAG_QUERY, Execution.OrderTag()) ||
					m_pTags->GetTags(MAP_CANCEL_TAG_QUERY, Execution.OrderTag()))
				{
					// set new order tag
					//m_pTags->SetOrderTag(m_pTags->CancelTag());
					//m_pTags->SetCancelTag(-1);

					// set exchange tag if needed
					if (Execution.ExchangeTag() != m_pTags->ExchangeTag())
						m_pTags->SetExchangeTag(Execution.ExchangeTag());

					// get the stafford tag based off of the order tag
					//Execution.SetStaffordTag(m_pTags->StaffordTag());


					pApp->ProcessDebug("RECV STATUS", Execution.Debug());

					// In addition to responding to Cancel/Replace request 
					// if Replaced status will be received only due to price move 
					// update the original price without telling traders
					
					//if (strncmp(Execution.Text(), "Replaced", 8) != 0)
					//if (Execution.Price() != m_pTags->Price())
					//{
					m_pTags->SetOriginalPrice(Execution.Price());
					m_pTags->SetShares(m_pTags->Shares() - m_pTags->OriginalShares() + Execution.Shares());
					m_pTags->SetOriginalShares(Execution.Shares());

					//}
					//else
					//{
						// get the stafford tag based off of the order tag
						Execution.SetStaffordTag(m_pTags->StaffordTag());

						// Resume sourceID
						Execution.SetSourceId(m_pTags->Client());

						// update Status
						Execution.SetStatus(COrder::Open);
						Execution.SetShares(m_pTags->Shares());
						pApp->Status().SetStatus(Execution);
					//}
				}
				else
				{
					Error.Format("Unable To Find Order Tag (%s) In Tag Map For OrderId(%s): (%s)", Execution.OrderTag(), Execution.StaffordTag(), Execution.Debug());
					pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Error);
				}
			}
			else 
			{
				BOOL bFound = FALSE;

				if (m_pTags->GetTags(MAP_ORDER_TAG_QUERY, Execution.OrderTag()))
					bFound = TRUE;
				else if (m_pTags->GetTags(MAP_CANCEL_TAG_QUERY, Execution.OrderTag()))
					bFound = TRUE;

				if(bFound)
				{
					// set exchange tag if needed
					if (Execution.ExchangeTag() != m_pTags->ExchangeTag())
						m_pTags->SetExchangeTag(Execution.ExchangeTag());
					
					// get the stafford tag based off of the order tag
					Execution.SetStaffordTag(m_pTags->StaffordTag());
					Execution.SetSourceId(m_pTags->Client());
					pApp->ProcessDebug("RECV STATUS", Execution.Debug());

					switch(Execution.Status())
					{
					case COrder::PartiallyFilled:
						m_pTags->SetShares(m_pTags->Shares() - Execution.LastShares());
						break;
					case COrder::Canceled:
					case COrder::Filled:
					case COrder::DoneForDay:
					case COrder::Stopped:
						m_pTags->RemoveTags();
						break;
					case COrder::Open:
						m_pTags->SetOriginalPrice(Execution.Price());

						// Bloomberg may do partial open
						// and TradeManager does not care
						Execution.SetShares(0);
						break;
					case COrder::Rejected:
						if (strcmp(m_pTags->CancelTag(), m_pTags->OrderTag()) != 0)
						{
							Execution.SetStatus(COrder::CancelRejected);
						}
						else
						{
							m_pTags->RemoveTags();
						}
						break;
					default:
						break;
					}
					// update Status
					pApp->Status().SetStatus(Execution);
					//m_pTags->Close();
				}
				else
				{
					Error.Format("Unable To Find Order Tag (%s) In Tag Map For OrderId(%s): (%s)", Execution.OrderTag(), Execution.StaffordTag(), Execution.Debug());
					pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Error);
				}
			}
		}
	}

	catch (CDBException *e)
	{
		Error.Format("EXCEPTION: Error Processing Incoming Status Message (%s): %s", e->m_strError, Execution.Debug());
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Error);
		e->Delete();
	}
}

void CBloombergHandler::ProcessMessage(CCancelReject& Reject)
{
	CString		Error;
	CMessageApp *pApp = (CMessageApp *)AfxGetApp();
	
	try
	{
		pApp->ProcessDebug("RECV STATUS", Reject.Debug());

		if (m_pTags->GetTags(MAP_CANCEL_TAG_QUERY, Reject.CancelTag()))
		{
			/*// set exchange tag if needed
			if ((Reject.ExchangeTag() != "") && (m_pTags->ExchangeTag() == ""))
				m_pTags->SetExchangeTag(Reject.ExchangeTag());
			*/
			// set the stafford tag based off of the order tag
			Reject.SetStaffordTag(m_pTags->StaffordTag());

			Reject.SetSourceId(m_pTags->Client());

			// update Status
			pApp->Status().SetStatus(Reject);
		}
	}

	catch (CDBException *e)
	{
		Error.Format("EXCEPTION: Error Processing Incoming Cancel Reject Message (%s): %s", e->m_strError, Reject.Debug());
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Error);
		e->Delete();
	}
}

void CBloombergHandler::ProcessMessage(CReject& Reject)
{
	CString	Error;
	CMessageApp *pApp = (CMessageApp *)AfxGetApp();
	
	try
	{
		pApp->ProcessDebug("RECV STATUS", Reject.Debug());

		if (m_pTags->GetTags(MAP_SEQUENCE_TAG_QUERY, Reject.OrderTag()))
		{
			// set tags
			Reject.SetOrderTag(m_pTags->OrderTag());
			Reject.SetExchangeTag(m_pTags->ExchangeTag());
			Reject.SetCancelTag(m_pTags->CancelTag());
			Reject.SetStaffordTag(m_pTags->StaffordTag());
			Reject.SetSourceId(m_pTags->Client());

			// update Status
			pApp->Status().SetStatus(Reject);
		}
	}

	catch (CDBException *e)
	{
		Error.Format("EXCEPTION: Error Processing Incoming Reject Message (%s): %s", e->m_strError, Reject.Debug());
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Error);
		e->Delete();
	}
}


void CBloombergHandler::ProcessMessage(CReplace& Replace)
{
	CMessageApp *pApp = (CMessageApp *) AfxGetApp();
	CFixedString CancelTag;

	try
	{
		if(m_pTags->GetTags(MAP_STAFFORD_TAG_QUERY, Replace.StaffordTag()))
		{
			// set the exchange's tag as the fix order tag
			// Note that Bloomberg only does modifing instead of Cancel/Replace
			// so we don't change ClientOrderID. 
			/*if (Replace.Price() != m_pTags->Price())
			{
				// generate reject
				Replace.SetSourceId(m_pTags->Client());
				CReject	Reject("Bloomberg does not allow price change in Cancel/Replace", Replace);		

				// update Status
				pApp->Status().SetStatus(Reject);
				pApp->ProcessDebug("SEND REJECT", "");
			}
			else
			{*/
				// Caliberate the new shares before sending to BTRD
				//if (m_pTags->Shares() != Replace.Shares())
				//{
					Replace.SetShares(m_pTags->OriginalShares() - m_pTags->Shares() + Replace.Shares());
				//}
				Replace.SetExchangeTag(m_pTags->ExchangeTag());
				Replace.SetOrderTag(m_pTags->OrderTag());
				//CancelTag = CTime::GetCurrentTime().Format("%Y%m%d");
				//CancelTag = CancelTag + (long)((CFixSession&) pApp->Exchange()).GetNextOutgoingSeqNum();
				//Replace.SetCancelTag(CancelTag.GetCString());
				Replace.SetCancelTag(m_pTags->OrderTag());
				Replace.SetOriginalShares(m_pTags->OriginalShares());
				Replace.SetOriginalPrice(m_pTags->OriginalPrice());
				if( pApp->Exchange().ProcessReplace(Replace) )
				{
					//m_pTags->SetCancelTag(Replace.CancelTag());
					pApp->ProcessDebug("REPLACE SENT", "");
				}
				else
				{
					Replace.SetSourceId(m_pTags->Client());
					// generate reject
					CReplaceReject Reject("Unable To Send", Replace);		
					// update Status
					pApp->Status().SetStatus(Reject);
					pApp->ProcessDebug("SEND REJECT", "");
				}
			//}
		}
	}
	catch (CDBException *e)
	{
		CString Error;
		Error.Format("EXCEPTION: Error Processing Outgoing Message (%s): %s", e->m_strError, "");
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Error);
		e->Delete();
	}
	catch (const char *Message)
	{
		pApp->ProcessErrorEx(MODE_ERR_DEVELOPER,"Bloomberg Handler", Message);
	}
}


void CBloombergHandler::ProcessMessage(const char *Status)
{

}